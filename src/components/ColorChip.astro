---
// ColorChip.astro - A reusable component for displaying color information
// Place this file in src/components/ColorChip.astro
import Color from 'color';

interface Props {
  name: string;
  color: string; // Single color input (hex, rgb, named color, etc.)
  description?: string;
}

const { name, color: colorValue, description } = Astro.props;

// Create a color object using the provided value
const colorObj = Color(colorValue);

// Derive all required color formats
const hex = colorObj.hex();
const rgb = colorObj.rgb().array().map(Math.round).join(', '); // Rounded whole numbers
const cmyk = colorObj
  .cmyk()
  .array()
  .map((v) => Math.round(v) + '%')
  .join(', '); // Percentages

// Calculate contrasting text color (white or black) based on the background color
// Using a simple approach based on the color's luminosity
const textColor = colorObj.isLight() ? '#000000' : '#FFFFFF';

// Generate a unique ID for this color chip's details
const detailsId = `color-details-${name.toLowerCase().replace(/\s+/g, '-')}`;
---

<div class="color-chip">
  <div
    class="color-preview"
    style={`background-color: ${hex}; color: ${textColor};`}
    data-details-id={detailsId}
    aria-expanded="false"
    aria-controls={detailsId}
  >
    <span class="color-name">{name}</span>
    <span class="expand-icon" aria-hidden="true">â–¼</span>
  </div>
  <div id={detailsId} class="color-details">
    <div class="color-value">
      <span class="value-label">HEX:</span>
      <code class="value-code">{hex}</code>
    </div>
    <div class="color-value">
      <span class="value-label">RGB:</span>
      <code class="value-code">{rgb}</code>
    </div>
    <div class="color-value">
      <span class="value-label">CMYK:</span>
      <code class="value-code">{cmyk}</code>
    </div>
    {description && <p class="color-description">{description}</p>}
  </div>
</div>

<style>
  .color-chip {
    display: flex;
    flex-direction: column;
    border-radius: 0.5rem;
    overflow: visible; /* Changed from hidden to visible to allow absolute positioned content to show */
    border: 1px solid var(--sl-color-gray-5);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    height: 100px; /* Fixed height for consistent grid layout */
    margin: 0;
    position: relative; /* Enable absolute positioning for children */
  }

  .color-preview {
    padding: 1.5rem;
    text-align: center;
    min-height: 5rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.2s ease;
    height: 100%; /* Take full height of parent */
  }

  .color-preview:hover {
    filter: brightness(0.95);
  }

  .color-name {
    margin: 0;
    font-size: 1.2rem;
    font-weight: 600;
  }

  .expand-icon {
    font-size: 0.8rem;
    transition: transform 0.3s ease;
  }

  .expand-icon.rotated {
    transform: rotate(180deg);
  }

  .color-details {
    position: absolute;
    top: 100%; /* Position right below the color chip */
    left: 0;
    right: 0;
    max-height: 0;
    overflow: hidden;
    transition:
      max-height 0.3s ease,
      box-shadow 0.3s ease;
    z-index: 10; /* Ensure it appears above other chips */
    border-radius: 0 0 0.5rem 0.5rem;
    margin-top: 0; /* No space between chip and details */

    /* Moved styles from color-info */
    padding: 0;
    background-color: var(--sl-color-gray-1);
    display: flex;
    flex-direction: column;
    border: 1px solid var(--sl-color-gray-5);
    border-top: none;
    box-sizing: border-box; /* Ensure padding is included in the element's total width and height */
  }

  /* Adjust position for chips at the bottom of the screen */
  .color-chip:has(.color-details.expanded) {
    z-index: 20; /* Ensure actively expanded chip is on top */
  }

  .color-details.expanded {
    max-height: 300px; /* Increased max height to accommodate larger content */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    padding: 1rem; /* Apply padding only when expanded to prevent overflow */
  }

  .color-value {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
  }

  .value-label {
    font-weight: 600;
    color: var(--sl-color-black); /* Much better contrast with background */
  }

  .value-code {
    font-family: var(--sl-font-mono);
    color: var(--sl-color-black);
    background-color: var(--sl-color-gray-1);
    padding: 0.2rem 0.4rem;
    border-radius: 0.25rem;
    font-weight: 500;
    display: inline-block;
    min-width: 100px;
    text-align: right;
    border: 1px solid var(--sl-color-gray-4);
  }

  .color-description {
    font-size: 0.9rem;
    margin: 0.5rem 0 0 0; /* Changed to top margin for better spacing */
    color: var(--sl-color-black); /* Maximum contrast for better accessibility */
    padding-bottom: 0; /* Ensure no padding at bottom */
    box-sizing: border-box; /* Ensure padding is included in height calculations */
  }
</style>

<style is:global>
  /* Add this global style to your ColorChip component */
  .color-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1.5rem;
    margin-bottom: 2rem;
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    // Add click event listeners to all color chip previews
    document.querySelectorAll('.color-preview').forEach((preview) => {
      preview.addEventListener('click', function (this: HTMLElement) {
        const detailsId = this.getAttribute('data-details-id');
        if (!detailsId) return;

        const details = document.getElementById(detailsId);
        const expandIcon = this.querySelector('.expand-icon');

        if (!details || !expandIcon) return;

        // Toggle expanded state
        const isExpanded = details.classList.toggle('expanded');
        expandIcon.classList.toggle('rotated');

        // Update ARIA attributes
        this.setAttribute('aria-expanded', isExpanded.toString());

        // Check if expanded details are visible in viewport
        if (isExpanded) {
          // Use requestAnimationFrame instead of setTimeout for better timing
          requestAnimationFrame(() => {
            const rect = details.getBoundingClientRect();
            const isOffscreen = rect.bottom > window.innerHeight;

            if (isOffscreen) {
              // If details extend beyond viewport, scroll them into view
              details.scrollIntoView({ behavior: 'smooth', block: 'end' });
            }
          });
        }
      });
    });
  });
</script>
